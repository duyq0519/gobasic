# Java网络IO

## 基本概念

### 同步与异步 

同步： 同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。

异步： 异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。



### 阻塞与非阻塞
阻塞： 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。

非阻塞： 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。

## linux五种网络模型

五种IO模型包括：阻塞IO、非阻塞IO、信号驱动IO、IO多路转接、异步IO。其中，前四个被称为同步IO。


## 网络模型
按照阻塞方式来分，网络模型分为BIO和NIO

### BIO（阻塞IO）
阻塞IO，数据的读取与写入必须在一个线程内完成。

#### 同步阻塞IO
传统的同步阻塞IO，一般会有一个全局的accept方法，接收连接请求，然后用一个单独的线程去处理数据的读取与写入，
这时候 不能进去新的连接请求，但是可以通过多线程的方式来实现多个连接


#### 伪异步 IO
在 Java 虚拟机中，线程是宝贵的资源，线程的创建和销毁成本很高，除此之外，线程的切换成本也是很高的。尤其在 Linux 这样的操作系统中，线程本质上就是一个进程，创建和销毁线程都是重量级的系统函数。如果并发访问量增加会导致线程数急剧膨胀可能会导致线程堆栈溢出、创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务。


采用线程池和任务队列可以实现一种叫做伪异步的 I/O 通信框架

#### 结论
在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。

### NIO（非阻塞IO）
非阻塞是IO，线程不必等待数据的写入读取耗时，可以去执行其他任务

#### 同步非阻塞IO
#### 异步非阻塞IO


## 网络框架Netty




## 参考
https://www.cnblogs.com/nxlhero/p/11678333.html
https://blog.csdn.net/weixin_38073885/article/details/90145803


netty
https://www.cnblogs.com/imstudy/p/9908791.html

使用idea


代码实现

netty代码实现
netty的主要的原理

然后用netty实现一个


主要是100个客户端向服务端发送消息的耗时，
作为比较工具

ppt的编写


lambda表达式
//https://www.jdon.com/idea/java/10-example-of-lambda-expressions-in-java8.html


事件驱动模型


多路复用

基于Buffer


PPT 就是几张图

主要的是代码

多线程
线程池
netty复用

今晚是基本代码的实现
明天调试代码，然后整理PPT


https://mp.weixin.qq.com/s?__biz=MzA3MDY0NTMxOQ==&mid=2247486566&idx=1&sn=82550b264e0b52681863355455655f0d&chksm=9f38ef4ea84f6658f1383df5c673bfbb484441e81b9440f65ec3d0211e797fc0b641b250b780&scene=0&xtrack=1#rd



https://mp.weixin.qq.com/s?__biz=MzU3MDc3OTI1NA==&mid=2247484023&idx=1&sn=bdf5a0743b754c3c0a248f85fc929ee3&chksm=fceb716ecb9cf8784c2b373fab476559d3fd1febf00b8215cf2d152ef797cb42e1a59f2e1cd2&token=1415493970&lang=zh_CN#rd



https://www.jianshu.com/p/a4e03835921a


多路複用
在l/O编程过程中,当需要同时处理多个客户端接入请求时, 可以利用多线程,或者l/O多路复用技术进行 处理。I/O多路复用技术通过把多个 I/O的阻塞复用到同一个 select的阻塞上, 从而使得系统在单线程的情況下可以同时处理多个客户端请求




Channel和Buffer
https://blog.csdn.net/qq_34626097/article/details/89222093